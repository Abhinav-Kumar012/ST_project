<!DOCTYPE html>
<html>
<head>
    <title>MutPy mutation report - mutation #15</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css">
    
<link href="http://alexgorbatchev.com/pub/sh/current/styles/shCore.css" rel="stylesheet" type="text/css" />
<link href="http://alexgorbatchev.com/pub/sh/current/styles/shThemeDefault.css" rel="stylesheet" type="text/css" />

    <script src="https://code.jquery.com/jquery.js"></script>
    <script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.3/js/bootstrap.min.js"></script>
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
    
<script src="http://alexgorbatchev.com/pub/sh/current/scripts/shCore.js" type="text/javascript"></script>
<script src="http://alexgorbatchev.com/pub/sh/current/scripts/shBrushPython.js" type="text/javascript"></script>
<script type="text/javascript">
    SyntaxHighlighter.all();
    window.setTimeout(function () {
        
        $('.line.number83').attr('title', 'LCR');
        
    }, 0);
</script>

</head>
<body>
    <div class="container">
        
<div class="page-header">
    <h1>Mutation #15</h1>
</div>
<h3>Details</h3>
<ul>
    <li>module - <code><module 'src.graph_algos' from '/mnt/c/Users/Gaming window/Desktop/ST_projects/ST_project/./src/graph_algos.py'></code></li>
    <li><span class="label label-info">timeout</span></li>
    
    <li>duration - 5.007 s</li>
    
    
</ul>

<h3>Mutations</h3>
<ul>
    
    <li>LCR - line 83</li>
    
</ul>
<h3>Mutant</h3>
<pre class="brush: python; first-line: 1; highlight: [83]; toolbar: false;">import heapq

class Graph:
    
    def __init__(self):
        self.adj_list = {}
    
    def add_edge(self, u, v, weight=1):
        if u not in self.adj_list:
            self.adj_list[u] = []
        if v not in self.adj_list:
            self.adj_list[v] = []
        self.adj_list[u].append((v, weight))
    
    def bfs(self, start_node):
        if start_node not in self.adj_list:
            return []
        visited = set()
        queue = [start_node]
        visited.add(start_node)
        traversal = []
        while len(queue) > 0:
            current = queue.pop(0)
            traversal.append(current)
            for (neighbor, weight) in self.adj_list.get(current, []):
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
        return traversal
    
    def dfs(self, start_node):
        if start_node not in self.adj_list:
            return []
        visited = set()
        stack = [start_node]
        traversal = []
        while len(stack) > 0:
            current = stack.pop()
            if current not in visited:
                visited.add(current)
                traversal.append(current)
                neighbors = self.adj_list.get(current, [])
                for i in range(len(neighbors) - 1, -1, -1):
                    (neighbor, weight) = neighbors[i]
                    if neighbor not in visited:
                        stack.append(neighbor)
        return traversal
    
    def dijkstra(self, start_node):
        if start_node not in self.adj_list:
            return {}
        
        distances = {node: float('inf') for node in self.adj_list}
        distances[start_node] = 0
        
        pq = [(0, start_node)]
        
        while len(pq) > 0:
            (current_dist, current_node) = heapq.heappop(pq)
            
            if current_dist > distances[current_node]:
                continue
            
            for (neighbor, weight) in self.adj_list.get(current_node, []):
                distance = current_dist + weight
                if distance < distances.get(neighbor, float('inf')):
                    distances[neighbor] = distance
                    heapq.heappush(pq, (distance, neighbor))
        
        return distances
    
    def bellman_ford(self, start_node):
        nodes = list(self.adj_list.keys())
        distances = {node: float('infinity') for node in nodes}
        distances[start_node] = 0
        for _ in range(len(nodes) - 1):
            for u in self.adj_list:
                for (v, weight) in self.adj_list[u]:
                    if (distances[u] != float('infinity') and distances[u] + weight < distances.get(v, float('infinity'))):
                        distances[v] = distances[u] + weight
        for u in self.adj_list:
            for (v, weight) in self.adj_list[u]:
                if (distances[u] != float('infinity') or distances[u] + weight < distances.get(v, float('infinity'))):
                    return None
        return distances
    
    def floyd_warshall(self):
        nodes = list(self.adj_list.keys())
        dist = {u: {v: float('infinity') for v in nodes} for u in nodes}
        for u in nodes:
            dist[u][u] = 0
            for (v, weight) in self.adj_list[u]:
                dist[u][v] = weight
        for k in nodes:
            for i in nodes:
                for j in nodes:
                    if dist[i][k] + dist[k][j] < dist[i][j]:
                        dist[i][j] = dist[i][k] + dist[k][j]
        return dist
    
    def topological_sort(self):
        '''Performs topological sort on a DAG.'''
        in_degree = {u: 0 for u in self.adj_list}
        for u in self.adj_list:
            for (v, weight) in self.adj_list[u]:
                in_degree[v] = in_degree.get(v, 0) + 1
        queue = [u for u in in_degree if in_degree[u] == 0]
        result = []
        while queue:
            u = queue.pop(0)
            result.append(u)
            for (v, weight) in self.adj_list.get(u, []):
                in_degree[v] -= 1
                if in_degree[v] == 0:
                    queue.append(v)
        if len(result) != len(self.adj_list):
            return None
        return result

class UnionFind:
    
    def __init__(self, elements):
        self.parent = {e: e for e in elements}
        self.rank = {e: 0 for e in elements}
    
    def find(self, item):
        if self.parent[item] != item:
            self.parent[item] = self.find(self.parent[item])
        return self.parent[item]
    
    def union(self, item1, item2):
        root1 = self.find(item1)
        root2 = self.find(item2)
        if root1 != root2:
            if self.rank[root1] > self.rank[root2]:
                self.parent[root2] = root1
            elif self.rank[root1] < self.rank[root2]:
                self.parent[root1] = root2
            else:
                self.parent[root2] = root1
                self.rank[root1] += 1
            return True
        return False

def kruskal_mst(graph):
    """Finds Minimum Spanning Tree using Kruskal's algorithm."""
    edges = []
    for u in graph.adj_list:
        for (v, weight) in graph.adj_list[u]:
            edges.append((weight, u, v))
    edges.sort()
    uf = UnionFind(graph.adj_list.keys())
    mst = []
    total_weight = 0
    for (weight, u, v) in edges:
        if uf.union(u, v):
            mst.append((u, v, weight))
            total_weight += weight
    return (mst, total_weight)

def prim_mst(graph, start_node):
    """Finds Minimum Spanning Tree using Prim's algorithm."""
    mst = []
    total_weight = 0
    visited = set([start_node])
    edges = []
    for (v, weight) in graph.adj_list[start_node]:
        heapq.heappush(edges, (weight, start_node, v))
    while edges:
        (weight, u, v) = heapq.heappop(edges)
        if v not in visited:
            visited.add(v)
            mst.append((u, v, weight))
            total_weight += weight
            for (next_v, next_w) in graph.adj_list[v]:
                if next_v not in visited:
                    heapq.heappush(edges, (next_w, v, next_v))
    return (mst, total_weight)

def has_cycle(graph):
    '''Detects if there is a cycle in an undirected graph.'''
    visited = set()
    
    def dfs(u, parent):
        visited.add(u)
        for (v, weight) in graph.adj_list.get(u, []):
            if v == parent:
                continue
            if v in visited:
                return True
            if dfs(v, u):
                return True
        return False
    for node in graph.adj_list:
        if node not in visited:
            if dfs(node, None):
                return True
    return False

def find_connected_components(graph):
    '''Finds all connected components in the graph.'''
    visited = set()
    components = []
    for node in graph.adj_list:
        if node not in visited:
            component = []
            queue = [node]
            visited.add(node)
            while queue:
                u = queue.pop(0)
                component.append(u)
                for (v, weight) in graph.adj_list.get(u, []):
                    if v not in visited:
                        visited.add(v)
                        queue.append(v)
            components.append(component)
    return components</pre>

    </div>
</body>
</html>